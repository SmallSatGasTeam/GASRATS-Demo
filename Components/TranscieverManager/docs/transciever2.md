[Link](https://usu.sharepoint.com/sites/GA/Shared%20Documents/Projects/GASRATS/EnduroSat%20Spec%20Sheets/UHF%20Transceiver%20II%20User%20Manual.pdf?CT=1741310232865&OR=ItemsView) to the manual
- We control it over I2C and we send/recieve data over UART (page 16)
- We can update the firmware on the fly, using their bootloader, but I'm not sure that's something we really want or need (page 24)
- Radio Packet Structure
    - uplink/downlink (the full packet starts with the first bullet point and ends with the last) (9.1)
        - Preamble (5 bytes)
            - Hard-coded value: 0xAAAAAAAAAA
        - Sync Word (1 byte)
            - Value: 0x7E
        - Data Field 1 (1 byte)
            - Size of data field 2 in bytes
        - Data Field 2 (0-128 bytes)
            - Payload
        - CRC16 (2 bytes)
            - I think this is some sort of cryptogrophy thing, but I'm not sure
            - It actually stands for cyclic redundancy check, which is an error-detecting code to check for errors in the data
            - It's applied to datafield 1 and 2
            - Its inital value is all 1's
                - 0xFFFF
                - 1111 1111 1111 1111
            - The most significant bit of each byte is processed first
            - How it works
                - uses the polynomial: $x^{16}+x^{12}+x^5+1$ which is `0x11021` or `10001000000100001`
                - then you divide the data by the polynomial which gives you the CRC16
                - I actually don't think we need to know this, just need to find someone who wrote the algoritim and apply it to Data-1 and Data-2
                    - the algorithm is called CRC-16/CCITT-FALSE
            - There's a CRC calculator within the `xHF and OBC Configurator` app, under Tools.
- How I think it'll all work
    - We should just have to specify the telemetry packetizer to work with our packets specifically, then send the packets to the transciever over I2C using fprime.  
    - Most info I've found out about the TlmPacketizer is [here](https://github.com/nasa/fprime/discussions/2560)
- The component we need is the [Communication adapter Interface](https://fprime.jpl.nasa.gov/latest/docs/reference/communication-adapter-interface)
    - This is in the fprime repo under fprime/Fw/Interfaces/CommandInterface.fppi
- What I'm learning today (3/24/2025)
    - So basically, the ports that the interafce has us use are using the ByteStreamDriver, which takes in bytes in real time (hence why it's a streamer) and puts it in a buffer (im pretty sure idk if that's right)
    - Then, after we get or send the bytes, we then use the Framer, which is the thing that formats the data that we're sending/reciving.
        - To implement our own framer & deframer for the transciever, look in [this document](../../../fprime/Svc/FramingProtocol/docs/sdd.md)
    - I think after we have these things properly done, we just need to send the data to the transciever over UART, and since it's supposedly formatted correctly by the framer (after we make our own implementation of it) it should just send over and be out of our hands
    - Communication Queue component
        - This is a priority queue that uses round-robin for tasks with equal priority
        - It's a priority queue of buffers - each buffer is also called a 'message' in their documentation
        - You have to configure each queue with a depth (size, in terms of amount of buffers) and then you have to give a priority for each buffer put in the queue
        - This needs to be used with the communication adapter to queue all data to be transmitted
 - Implementation
    - Communication adapter - The purpose of this is to interact with the Framer and the Communication Queue components
        - This is responsible for any re-transmission of failed data
        - All this is doing, is using the Byte Stream Driver to take in the buffers from all the internal components, using the Framer to format the data for the transciever, and then the communication status component to say if things worked or didn't
    - Gemini's code review
        - This code mostly looks good from what I can tell
        - I had to change a few things, and haven't looked at the overall frame creation at the end
        - Need to add the preamble, flag, postamble, the second flag, and the post amble for the AX.25 frame because it didn't do that for some reason
- note for me when I come back on Thursday (4/10):
    - BUILD A DEPLOYMENT AND HOOK UP EVERYTHING CORRECTLY