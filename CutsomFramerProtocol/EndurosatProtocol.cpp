// This is the actual implementation that'll abide by how things should be setup for the transciever

#include "EndurosatProtocol.hpp"
#include "FpConfig.hpp"
#include <cstring>

namespace Svc {
    EndurosatFraming::EndurosatFraming(): FramingProtocol() {}

    EndurosatDeframing::EndurosatDeframing(): DeframingProtocol() {}

    // This was generated by Gemini i have no idea if it works or not
    // this calculates the CRC thingy that the transciever needs
    // im confident it probably works because it's basically identical to this real code: https://github.com/jpralves/crc16/blob/master/crc16.cpp
    // the only thing it does different is that since we're going over many bytes, it iterates over every byte and shifts it left to make it the most significant byte
    U16 calculate_crc16(const U8* data, U32 size) {
        U16 crc = 0xFFFF; // Initial value (all 1's)
        for (U32 i = 0; i < size; ++i) { // iterate over each byte
            crc ^= data[i] << 8; // this is XORing the new data into the crc, and shifting it left since that's how we build the crc check
            // it does this because to calculate crc16 we need to divide this data bpolynomial by another polynomial, and the remainder of this division is the crc
            // long division uses subtraction at each step, and this CRC check uses GF(2) arithmetic, which state that XORing is the same as subtracting, so that's why we XOR it
            for (int j = 0; j < 8; ++j) { // go over each of the 8 bits of the byte we just put into the crc
                if (crc & 0x8000) {
                    crc = (crc << 1) ^ 0x1021; // 0x1021 is the polynomial x^16 +x^12 + x^5 +1
                } else {
                    crc <<= 1;
                }
            }
        }
        return crc;
    } 

    void EndurosatFraming::frame(const U8* const data, const U32 size, Fw::ComPacket::ComPacketType packet_type) {
        FW_ASSERT(data != nullptr);
       
        // THIS IS AI STUFF STARTING HERE IDK IF THIS'LL WORK AT ALL

        // AX.25 Frame Construction
        U8 ax25_frame[size]; // making the frame as an array of bytes
        U32 ax25_frame_size = 0;

        // preamble 
        U8 preamble[] = {0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E};
        memcpy(ax25_frame, preamble, 8);
        ax25_frame_size += 8; // increase the size by the 8 bytes we're adding

        // starting flag
        U8 flag[] = { 0x7E };
        memcpy(ax25_frame, flag, 1);
        ax25_frame_size += 1; // increase the frame size by the one byte we're adding

        // Destination Address (Example - Replace with your actual formatting)
        U8 dest_callsign[] = "DEST   ";  // 6 bytes, left-justified, shifted - only 7 characters because we're gonna add the frame size to the callsign
        U8 dest_ssid = 0xE0;   // SSID given from the datasheet
        memcpy(ax25_frame, dest_callsign, 6); // copy the call sign to the frame, and tell it that it's 6 bytes 
        ax25_frame[6] = dest_ssid; // add the ssid to the frame
        ax25_frame_size += 7; // the destination callsign and also the source callsign are both 7 bytes long
        
        // Source Address (Example - Replace with your actual formatting)
        U8 src_callsign[] = "SOURCE ";  // 6 bytes - 1 char = 1 byte - it has 7 characters because we're gonna add the frame size to the callsign bc why not ig
        U8 src_ssid = 0xE1;   // SSID given from the datasheet
        memcpy(ax25_frame + ax25_frame_size, src_callsign, 6); // add the frame size to the source callsign ig bc we can
        ax25_frame[ax25_frame_size + 6] = src_ssid; // at the current end of the frame add 6 more bytes and set at to the src ssid
        ax25_frame_size += 7; // the size of the source callsign is 7 bytes

        // Control Field (UI Frame)
        ax25_frame[ax25_frame_size++] = 0x03; // add this onto the current end of the frame
        
        // Protocol Identifier (No Layer 3 Protocol)
        ax25_frame[ax25_frame_size++] = 0xF0; // add this onto the current end of the frame

        // Information Field (Your Data)
        memcpy(ax25_frame + ax25_frame_size, data, size); // copy the data to the frame given the data and the size of the data
        ax25_frame_size += size; // increase the frame size by the size of the data
        
        // FCS (CRC-16) - this is the one within the second data field
        U16 crc = calculate_crc16(ax25_frame, ax25_frame_size); // calculate the crc within data field 2
        // since crc is a U16, we need to split it into two bytes
        ax25_frame[ax25_frame_size++] = crc & 0xFF;        // Least significant byte of crc needs to be 'transmitted' first - this maintains the right byte
        ax25_frame[ax25_frame_size++] = (crc >> 8) & 0xFF; // then the most significant byte will be sent - this maintains the left byte
        
        // Ending flag
        memcpy(ax25_frame, flag, 1);

        // postamble
        U8 postamble[] = {0x7E, 0x7E, 0x7E};
        memcpy(ax25_frame, postamble, 3);

        // Overall Radio Packet Construction
        U8 radio_packet[size]; // Adjust size as needed
        U32 radio_packet_size = 0;
        
        // Preamble
        U8 preamble[] = {0xAA, 0xAA, 0xAA, 0xAA, 0xAA};
        memcpy(radio_packet, preamble, 5);
        radio_packet_size += 5;
        
        // Sync Word
        radio_packet[radio_packet_size++] = 0x7E; // adding this to the packet and increasing its size at the same time
        
        // Data Field 1 (Length of Data Field 2)
        radio_packet[radio_packet_size++] = ax25_frame_size;
        
        // Data Field 2 (AX.25 Frame)
        memcpy(radio_packet + radio_packet_size, ax25_frame, ax25_frame_size); // this copies 'radio_packet_size' amount of bytes to the right of where the 'radio_packet' data is stored in memory, so it places the ax25_frame in the correct spot in memory (after the preamble, sync word, and data-field1)
        radio_packet_size += ax25_frame_size; // increase the overall packet size by the size of the ax25 frame
        
        // CRC16 for Radio Packet (Data Field 1 + Data Field 2)
        // im trusting Gemini on this one, i have no idea if it'll work
        crc = calculate_crc16(radio_packet + 6, radio_packet_size - 6);  // CRC over Data Field 1 and 2
        radio_packet[radio_packet_size++] = crc & 0xFF; // crc stuff that i don't understand
        radio_packet[radio_packet_size++] = (crc >> 8) & 0xFF; // supposedly more crc things that im hoping just work
    }
} // namespace Svc
