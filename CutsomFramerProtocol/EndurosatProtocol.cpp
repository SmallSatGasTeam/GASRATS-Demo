// This is the actual implementation that'll abide by how things should be setup for the transciever

#include "EndurosatProtocol.hpp"
#include "FpConfig.hpp"
#include <cstring>

namespace Svc {
    EndurosatFraming::EndurosatFraming(): FramingProtocol() {}

    EndurosatDeframing::EndurosatDeframing(): DeframingProtocol() {}


    // This was generated by Gemini i have no idea if it works or not
    // this calculates the CRC thingy that the transciever needsd
    U16 calculate_crc16(const U8* data, U32 size) {
        U16 crc = 0xFFFF; // Initial value (all 1's)
        for (U32 i = 0; i < size; ++i) {
            crc ^= data[i] << 8;
            for (int j = 0; j < 8; ++j) {
                if (crc & 0x8000) {
                    crc = (crc << 1) ^ 0x1021; // 0x1021 is the polynomial
                } else {
                    crc <<= 1;
                }
            }
        }
        return crc;
    }

    void EndurosatFraming::frame(const U8* const data, const U32 size, Fw::ComPacket::ComPacketType packet_type) {
        FW_ASSERT(data != nullptr);
        
        // Preamble 
        // i guess things are serialized as I32's so we need to convert to that
        // this is a ternary operator choosing between 0 and its size as long as the type isn't an unknown type           
        EndFrameHeader::TokenType real_data_size = 
            size + ((packet_type != Fw::ComPacket::FW_PACKET_UNKNOWN) ?
            static_cast<Svc::EndFrameHeader::TokenType>(sizeof(I32)) : 0
        );

        // need to add to the total size before making the buffer
        real_data_size += 2; // this'll add the size of the sync word and dataField1 to the total size

        // data field 1 - this holds the size of the data to be transmitted
        // 'data' is a pointer to a place in memory where a set of bytes is
        // the transciever can only handle up to 128 bytes, and the size of that can be represented by one byte
        const U8 dataField1 = static_cast<U8>(size); // this should be fine as so long as 'size' doesn't go over the size of a byte


        EndFrameHeader::TokenType total = real_data_size + EndFrameHeader::SIZE;


        // this is the buffer that'll hold everything
        Fw::Buffer buffer = m_interface->allocate(total); // this is 'implementing' the things from ProtocolInterface
        Fw::SerializeBufferBase& serializer = buffer.getSerializeRepr(); // serialize the buffer

        // now we need to serialize the data
        serializer.serialize(EndFrameHeader::PREAMBLE);
        serializer.serialize(dataField1);

        // need to go over all the data being sent, making sure to not send too much
        for (int i = 0; i < size && i < 128; i++) { // this is dataField2
            serializer.serialize(data[i]);
        }

        // THIS IS AI STUFF IDK IF THIS'LL WORK AT ALL

        // AX.25 Frame Construction
        //  This is a simplified example. You'll need to implement the AX.25 address formatting correctly.
        U8 ax25_frame[256]; // Adjust size as needed
        U32 ax25_frame_size = 0;
        

        // Destination Address (Example - Replace with your actual formatting)
        U8 dest_callsign[] = "DEST   ";  // 6 bytes, left-justified, shifted
        U8 dest_ssid = 0x60;   // Example SSID (rightmost bit is 1 for last address)
        memcpy(ax25_frame, dest_callsign, 6);
        ax25_frame[6] = dest_ssid;
        ax25_frame_size += 7;
        

        // Source Address (Example - Replace with your actual formatting)
        U8 src_callsign[] = "SOURCE ";  // 6 bytes
        U8 src_ssid = 0xE0;   // Example SSID
        memcpy(ax25_frame + ax25_frame_size, src_callsign, 6);
        ax25_frame[ax25_frame_size + 6] = src_ssid;
        ax25_frame_size += 7;
        

        // Control Field (UI Frame)
        ax25_frame[ax25_frame_size++] = 0x03;
        

        // Protocol Identifier (No Layer 3 Protocol)
        ax25_frame[ax25_frame_size++] = 0xF0;
        

        // Information Field (Your Data)
        memcpy(ax25_frame + ax25_frame_size, data, size);
        ax25_frame_size += size;
        

        // FCS (CRC-16)
        U16 crc = calculate_crc16(ax25_frame, ax25_frame_size);
        ax25_frame[ax25_frame_size++] = crc & 0xFF;        // Least significant byte first
        ax25_frame[ax25_frame_size++] = (crc >> 8) & 0xFF;
        

        // Radio Packet Construction
        U8 radio_packet[256]; // Adjust size as needed
        U32 radio_packet_size = 0;
        

        // Preamble
        U8 preamble[] = {0xAA, 0xAA, 0xAA, 0xAA, 0xAA};
        memcpy(radio_packet, preamble, 5);
        radio_packet_size += 5;
        

        // Sync Word
        radio_packet[radio_packet_size++] = 0x7E;
        

        // Data Field 1 (Length of Data Field 2)
        radio_packet[radio_packet_size++] = ax25_frame_size;
        

        // Data Field 2 (AX.25 Frame)
        memcpy(radio_packet + radio_packet_size, ax25_frame, ax25_frame_size);
        radio_packet_size += ax25_frame_size;
        

        // CRC16 for Radio Packet (Data Field 1 + Data Field 2)
        crc = calculate_crc16(radio_packet + 6, radio_packet_size - 6);  // CRC over Data Field 1 and 2
        radio_packet[radio_packet_size++] = crc & 0xFF;
        radio_packet[radio_packet_size++] = (crc >> 8) & 0xFF;
        
        
    }
} // namespace Svc
