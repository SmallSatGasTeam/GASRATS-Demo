// This is the actual implementation that'll abide by how things should be setup for the transciever

#include "EndurosatProtocol.hpp"
#include "FpConfig.hpp"
#include <cstring>

namespace Svc {
    EndurosatFraming::EndurosatFraming(): FramingProtocol() {}

    EndurosatDeframing::EndurosatDeframing(): DeframingProtocol() {}

    // This was generated by Gemini i have no idea if it works or not
    // this calculates the CRC thingy that the transciever needs
    U16 calculate_crc16(const U8* data, U32 size) {
        U16 crc = 0xFFFF; // Initial value (all 1's)
        for (U32 i = 0; i < size; ++i) { // iterate over each byte
            crc ^= data[i] << 8; // make it the most significant byte of the 16 crc number
            for (int j = 0; j < 8; ++j) { // go over each of the 8 bits of the byte we just put into the crc
                if (crc & 0x8000) {
                    crc = (crc << 1) ^ 0x1021; // 0x1021 is the polynomial x^16 +x^12 + x^5 +1
                } else {
                    crc <<= 1;
                }
            }
        }
        return crc;
    } /* REALLY SHOULD TEST THIS - 
        the calculated value for the standard sequence of ASCII characters “123456789” would be: 0xCBF43926
        */

    void EndurosatFraming::frame(const U8* const data, const U32 size, Fw::ComPacket::ComPacketType packet_type) {
        FW_ASSERT(data != nullptr);
        
        // Preamble 
        // i guess things are serialized as I32's so we need to convert to that
        // this is a ternary operator choosing between 0 and its size as long as the type isn't an unknown type           
        EndFrameHeader::TokenType real_data_size = 
            size + ((packet_type != Fw::ComPacket::FW_PACKET_UNKNOWN) ?
            static_cast<Svc::EndFrameHeader::TokenType>(sizeof(I32)) : 0
        );

        // need to add to the total size before making the buffer
        real_data_size += 2; // this'll add the size of the sync word and dataField1 to the total size

        // data field 1 - this holds the size of the data to be transmitted
        // 'data' is a pointer to a place in memory where a set of bytes is
        // the transciever can only handle up to 128 bytes, and the size of that can be represented by one byte
        const U8 dataField1 = static_cast<U8>(size); // this should be fine as so long as 'size' doesn't go over the size of a byte


        EndFrameHeader::TokenType total = real_data_size + EndFrameHeader::SIZE;


        // this is the buffer that'll hold everything
        Fw::Buffer buffer = m_interface->allocate(total); // this is 'implementing' the things from ProtocolInterface
        Fw::SerializeBufferBase& serializer = buffer.getSerializeRepr(); // serialize the buffer

        // now we need to serialize the data
        serializer.serialize(EndFrameHeader::PREAMBLE);
        serializer.serialize(dataField1);

        // need to go over all the data being sent, making sure to not send too much
        for (int i = 0; i < size && i < 128; i++) { // this is dataField2
            serializer.serialize(data[i]);
        }

        // THIS IS AI STUFF STARTING HERE IDK IF THIS'LL WORK AT ALL

        // AX.25 Frame Construction
        //  This is a simplified example. You'll need to implement the AX.25 address formatting correctly.
        U8 ax25_frame[size]; // making the frame as an array of bytes
        U32 ax25_frame_size = 0;

        // Destination Address (Example - Replace with your actual formatting)
        U8 dest_callsign[] = "DEST   ";  // 6 bytes, left-justified, shifted - only 7 characters because we're gonna add the frame size to the callsign
        U8 dest_ssid = 0xE0;   // SSID given from the datasheet
        memcpy(ax25_frame, dest_callsign, 6); // copy the call sign to the frame, and tell it that it's 6 bytes 
        ax25_frame[6] = dest_ssid; // add the ssid to the frame
        ax25_frame_size += 7; // the destination callsign and also the source callsign are both 7 bytes long
        
        // Source Address (Example - Replace with your actual formatting)
        U8 src_callsign[] = "SOURCE ";  // 6 bytes - 1 char = 1 byte - it has 7 characters because we're gonna add the frame size to the callsign bc why not ig
        U8 src_ssid = 0xE1;   // SSID given from the datasheet
        memcpy(ax25_frame + ax25_frame_size, src_callsign, 6); // add the frame size to the source callsign ig bc we can
        ax25_frame[ax25_frame_size + 6] = src_ssid; // at the current end of the frame add 6 more bytes and set at to the src ssid
        ax25_frame_size += 7; // the size of the source callsign is 7 bytes

        // Control Field (UI Frame)
        ax25_frame[ax25_frame_size++] = 0x03; // add this onto the current end of the frame
        
        // Protocol Identifier (No Layer 3 Protocol)
        ax25_frame[ax25_frame_size++] = 0xF0; // add this onto the current end of the frame

        // Information Field (Your Data)
        memcpy(ax25_frame + ax25_frame_size, data, size); // copy the data to the frame given the data and the size of the data
        ax25_frame_size += size; // increase the frame size by the size of the data
        
        // FCS (CRC-16) - this is the one within the second data field
        U16 crc = calculate_crc16(ax25_frame, ax25_frame_size); // calculate the crc within data field 2
        // since crc is a U16, we need to split it into two bytes
        ax25_frame[ax25_frame_size++] = crc & 0xFF;        // Least significant byte of crc needs to be 'transmitted' first - this maintains the right byte
        ax25_frame[ax25_frame_size++] = (crc >> 8) & 0xFF; // then the most significant byte will be sent - this maintains the left byte
        
        // Radio Packet Construction
        U8 radio_packet[size]; // Adjust size as needed
        U32 radio_packet_size = 0;
        
        // Preamble
        U8 preamble[] = {0xAA, 0xAA, 0xAA, 0xAA, 0xAA};
        memcpy(radio_packet, preamble, 5);
        radio_packet_size += 5;
        
        // Sync Word
        radio_packet[radio_packet_size++] = 0x7E;
        
        // Data Field 1 (Length of Data Field 2)
        radio_packet[radio_packet_size++] = ax25_frame_size;
        
        // Data Field 2 (AX.25 Frame)
        memcpy(radio_packet + radio_packet_size, ax25_frame, ax25_frame_size);
        radio_packet_size += ax25_frame_size;
        
        // CRC16 for Radio Packet (Data Field 1 + Data Field 2)
        crc = calculate_crc16(radio_packet + 6, radio_packet_size - 6);  // CRC over Data Field 1 and 2
        radio_packet[radio_packet_size++] = crc & 0xFF;
        radio_packet[radio_packet_size++] = (crc >> 8) & 0xFF;
    }
} // namespace Svc
