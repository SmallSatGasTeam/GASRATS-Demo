// This is the actual implementation that'll abide by how things should be setup for the transciever

#include "EndurosatProtocol.hpp"
#include "FpConfig.hpp"
#include <cstring>

namespace Svc {
    EndurosatFraming::EndurosatFraming(): FramingProtocol() {}

    EndurosatDeframing::EndurosatDeframing(): DeframingProtocol() {}

    // This was generated by Gemini i have no idea if it works or not
    // this calculates the CRC thingy that the transciever needs
    // im confident it probably works because it's basically identical to this real code: https://github.com/jpralves/crc16/blob/master/crc16.cpp
    // the only thing it does different is that since we're going over many bytes, it iterates over every byte and shifts it left to make it the most significant byte
    U16 calculate_crc16(const U8* data, U32 size) {
        U16 crc = 0xFFFF; // Initial value (all 1's)
        for (U32 i = 0; i < size; ++i) { // iterate over each byte
            crc ^= data[i] << 8; // this is XORing the new data into the crc, and shifting it left since that's how we build the crc check
            // it does this because to calculate crc16 we need to divide this data bpolynomial by another polynomial, and the remainder of this division is the crc
            // long division uses subtraction at each step, and this CRC check uses GF(2) arithmetic, which state that XORing is the same as subtracting, so that's why we XOR it
            for (int j = 0; j < 8; ++j) { // go over each of the 8 bits of the byte we just put into the crc
                if (crc & 0x8000) {
                    crc = (crc << 1) ^ 0x1021; // 0x1021 is the polynomial x^16 +x^12 + x^5 +1
                } else {
                    crc <<= 1;
                }
            }
        }
        return crc;
    } 

    void EndurosatFraming::frame(const U8* const data, const U32 size, Fw::ComPacket::ComPacketType packet_type) {
        FW_ASSERT(data != nullptr);
       
        // THIS IS AI STUFF STARTING HERE IDK IF THIS'LL WORK AT ALL

        // AX.25 Frame Construction
        U8 ax25_frame[size]; // making the frame as an array of bytes
        U32 ax25_frame_size = 0;

        // preamble 
        U8 preamble[] = {0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E};
        memcpy(ax25_frame, preamble, 8);
        ax25_frame_size += 8; // increase the size by the 8 bytes we're adding

        // starting flag
        U8 flag[] = { 0x7E };
        memcpy(ax25_frame, flag, 1);
        ax25_frame_size += 1; // increase the frame size by the one byte we're adding

        // Destination Address (Example - Replace with your actual formatting)
        U8 dest_callsign[] = "DEST   ";  // 6 bytes, left-justified, shifted - only 7 characters because we're gonna add the frame size to the callsign
        U8 dest_ssid = 0xE0;   // SSID given from the datasheet
        memcpy(ax25_frame, dest_callsign, 6); // copy the call sign to the frame, and tell it that it's 6 bytes 
        ax25_frame[6] = dest_ssid; // add the ssid to the frame
        ax25_frame_size += 7; // the destination callsign and also the source callsign are both 7 bytes long
        
        // Source Address (Example - Replace with your actual formatting)
        U8 src_callsign[] = "SOURCE ";  // 6 bytes - 1 char = 1 byte - it has 7 characters because we're gonna add the frame size to the callsign bc why not ig
        U8 src_ssid = 0xE1;   // SSID given from the datasheet
        memcpy(ax25_frame + ax25_frame_size, src_callsign, 6); // add the frame size to the source callsign ig bc we can
        ax25_frame[ax25_frame_size + 6] = src_ssid; // at the current end of the frame add 6 more bytes and set at to the src ssid
        ax25_frame_size += 7; // the size of the source callsign is 7 bytes

        // Control Field (UI Frame)
        ax25_frame[ax25_frame_size++] = 0x03; // add this onto the current end of the frame
        
        // Protocol Identifier (No Layer 3 Protocol)
        ax25_frame[ax25_frame_size++] = 0xF0; // add this onto the current end of the frame

        // Information Field (Your Data)
        memcpy(ax25_frame + ax25_frame_size, data, size); // copy the data to the frame given the data and the size of the data
        ax25_frame_size += size; // increase the frame size by the size of the data
        
        // FCS (CRC-16) - this is the one within the second data field
        U16 crc = calculate_crc16(ax25_frame, ax25_frame_size); // calculate the crc within data field 2
        // since crc is a U16, we need to split it into two bytes
        ax25_frame[ax25_frame_size++] = crc & 0xFF;        // Least significant byte of crc needs to be 'transmitted' first - this maintains the right byte
        ax25_frame[ax25_frame_size++] = (crc >> 8) & 0xFF; // then the most significant byte will be sent - this maintains the left byte
        
        // Ending flag
        memcpy(ax25_frame, flag, 1);

        // postamble
        U8 postamble[] = {0x7E, 0x7E, 0x7E};
        memcpy(ax25_frame, postamble, 3);

        // Overall Radio Packet Construction
        U8 radio_packet[size]; // Adjust size as needed
        U32 radio_packet_size = 0;
        
        // Preamble
        U8 preamble[] = {0xAA, 0xAA, 0xAA, 0xAA, 0xAA};
        memcpy(radio_packet, preamble, 5);
        radio_packet_size += 5;
        
        // Sync Word
        radio_packet[radio_packet_size++] = 0x7E; // adding this to the packet and increasing its size at the same time
        
        // Data Field 1 (Length of Data Field 2)
        radio_packet[radio_packet_size++] = ax25_frame_size;
        
        // Data Field 2 (AX.25 Frame)
        memcpy(radio_packet + radio_packet_size, ax25_frame, ax25_frame_size); // this copies 'radio_packet_size' amount of bytes to the right of where the 'radio_packet' data is stored in memory, so it places the ax25_frame in the correct spot in memory (after the preamble, sync word, and data-field1)
        radio_packet_size += ax25_frame_size; // increase the overall packet size by the size of the ax25 frame
        
        // CRC16 for Radio Packet (Data Field 1 + Data Field 2)
        // im trusting Gemini on this one, i have no idea if it'll work (it probably won't)
        crc = calculate_crc16(radio_packet + 6, radio_packet_size - 6);  // CRC over Data Field 1 and 2
        // this adds 6 to the radio_packet pointer, so it skips the preamble and sync word so it just points to data field 1 and 2
        // we subtract the size by 6 since that'll just give us the size of data field 1 + data field 2

        radio_packet[radio_packet_size++] = crc & 0xFF; // crc is a 16 bit number, so performing this AND operation will keep only the last 8 bits and set all other to 0
        radio_packet[radio_packet_size++] = (crc >> 8) & 0xFF; // this shifts crc16 8 bits to the right, and then preserves those 8 bits that were the MSB's but are now on the left so they're preserved by the AND operation and then added onto the overall packet
    }

    bool EndurosatDeframing::validate(Types::CircularBuffer& ring, U32 size) {
        // to validate the data, just perform the crc calculation on data field 1 and 2 and see if it matches the crc the packet holds
        U8* data;
        ring.peek(data, size); // this starts at the head by default, so this should be the buffer for all the data
        
        // calculate the crc16 value we expect it to have
        U16 expected_crc = calculate_crc16(data, size);

        U16 given_crc = 0xFFFF; // start with all 1's
        given_crc = given_crc & (data[size - 2] << 8); // the first half of the given crc
        given_crc = given_crc & data[size - 1]; // the second half of the given crc

        if (given_crc != expected_crc) {
            return false;
        } else {
            return true;
        }

    }

    DeframingProtocol::DeframingStatus EndurosatDeframing::deframe(Types::CircularBuffer& ring, U32& needed) {
        FW_ASSERT(m_interface != nullptr);

        // just go through the ring and read all the data 
        // need to keep checking the size of the ring to see if it's the size we're expecting as defined by data field 1

        // first we need to check if it even has data field 1, which holds the size of data field 2 which is the only part of the packet that varies in size
        if (ring.get_allocated_size() < 6) {
            needed = 6;
            return DeframingProtocol::DEFRAMING_MORE_NEEDED;
        }

        // then once we know the size after we get data field 1, we need to wait until the size = 7 + size of data field 2 + 2
        U8 size_field_1; // size of data field 1 defined by data field 1
        ring.peek(size_field_1, 6);

        U8 total_packet_size = size_field_1 + 9; // add the size of the other fixed sized sections

        if (ring.get_allocated_size() < total_packet_size) {
            needed = total_packet_size;
            return DeframingProtocol::DEFRAMING_INVALID_SIZE;
        }

        // check that it's bigger than we expected

        if (total_packet_size > ring.get_capacity()) {
            // size is too large so we don't give a 'needed' since it would overflow
            return DeframingProtocol::DEFRAMING_INVALID_SIZE;
        }

        // once we know we have the amount of data we'd expect, we can check if it's valid and use the data

    }
} // namespace Svc
